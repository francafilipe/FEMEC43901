# -*- coding: utf-8 -*-
"""Entrega1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xRS2d2w3_rUqgMpwmCgEx3ZzTre3MAxU
"""

def bissec(f, a, b, delta, TOL, n):  
    i = 1  
    while (i <= n):  
        #iteracao da bissecao  
        c = (a+b)/2  
        fc = f(c)  
        if (f(c+delta)>=f(c-delta)):
          b=c
          fc=f(b)
        elif (f(c+delta)<f(c-delta)):
          a=c
          fc=f(a)
        else:
          print('Entre com um novo intervalor [a,b] ou verifique delta')
          return None
        #condicao de parada  
        if (((b-a)/2 < TOL)):  
            return c  
        i=i+1
 
    raise NameError('Reveja o número de iterações!'); #caso se passe o número de alterações

def aurea(f,a,b,TOL,n):
  tal = 0.618034
  i=1
  alfa=a+(1-tal)*(b-a)
  beta=a+tal*(b-a)
  while (i <= n):
    if (f(alfa)>=f(beta)):
      a=alfa
      alfa=beta
      beta=a+tal*(b-a)
    elif (f(alfa)<f(beta)):
      b=beta
      beta=alfa
      alfa=a+(1-tal)*(b-a)
    else:
      print('Entre com um novo intervalor [a,b] ou verifique delta')
      return None
    #condicao de parada  
    if (((beta-alfa)/2 < TOL)):  
      return (beta+alfa)/2
    i=i+1
  raise NameError('Reveja o número de iterações!'); #caso se passe o número de alterações

from math import sqrt
def F(n): #fibonacci
  fib=(sqrt(5)/5)*(((1+sqrt(5))/2)**(n+1))-(sqrt(5)/5)*(((1-sqrt(5))/2)**(n+1))
  return fib

def fibo(f,a,b,TOL,n):
  i=1
  tal=(F(n-i+1)/F(n-i+2))
  lamb=1-tal
  alfa=a+lamb*(b-a)
  beta=b-lamb*(b-a)
  while (i<=n):
    if(f(alfa)>=f(beta)):
      a=alfa
      alfa=beta
      beta=b-lamb*(b-a)
    elif (f(alfa)<f(beta)):
      b=beta
      beta=alfa
      alfa=a+lamb*(b-a)
    else:
      print('Entre com um novo intervalor [a,b] ou verifique delta')
      return None
    #condicao de parada  
    if (((beta-alfa)/2 < TOL)):  
      return (beta+alfa)/2
    i=i+1
    tal=(F(n-i+1)/F(n-i+2))
    lamb=1-tal

from math import *

def default(x):
  E= 5000 #kN/cm²
  I= 3000 #cm^4
  L = 600 #cm
  w= 2.5 #kN/cm
  f=w/(120*E*I*L)*(-x**5+2*L**2*x**3-L**4*x)
  return f

def sphere(x):
  f=x**2
  return f

def beale(x,y=0.5):
  f=(1.5-x+x*y)**2+(2.25-x+x*y**2)**2+(2.625-x+x*y**3)**2
  return f

def three(x,y=0):
  f=2*x**2-1.05*x**4+(1/6)*x**6+x*y+y**2
  return f

def rastrigin (x):
  f=10+x**2-10*cos(2*pi*x)
  return f

print('Bissecção para função Default:', bissec(default,0,600,0.2,0.001,100))
print('Aurea para função Default:', aurea(default,0,600,0.001,100))
print('Fibonacci para função Default:', fibo(default,0,600,0.001,100))
print('-----------------------')
print('Bissecção para função Sphere:', bissec(sphere,-4.9,5,0.2,0.001,100))
print('Aurea para função Sphere:', aurea(sphere,-4.9,5,0.001,100))
print('Fibonacci para função Sphere:', fibo(sphere,-4.9,5,0.001,100))
print('-----------------------')
print('Bissecção para função Beale:', bissec(beale,-4.5,4.5,0.2,0.001,100))
print('Aurea para função Beale:', aurea(beale,-4.5,4.5,0.001,100))
print('Fibonacci para função Beale:', fibo(beale,-4.5,4.5,0.001,100))
print('-----------------------')
print('Bissecção para função Three:', bissec(three,-1.6,1.6,0.2,0.001,100))
print('Aurea para função Three:', aurea(three,-1.6,1.6,0.001,100))
print('Fibonacci para função Three:', fibo(three,-1.6,1.6,0.001,100))